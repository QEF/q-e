input_description -distribution {Quantum Espresso} -package PWscf -program pw.x {

    toc {}

    intro {
	Input data format: { } = optional, [ ] = it depends, | = or
	
	All quantities whose dimensions are not explicitly specified are in
	RYDBERG ATOMIC UNITS

	Structure of the input data:
	===============================================================================

	&CONTROL
	  ...
	/

	&SYSTEM
	 ...
	/

	&ELECTRONS
	...
	/

	[ &IONS
	  ...
	 / ]

	[ &CELL
	  ...
	 / ]

	[ &PHONON
	  ...
	 / ]

	[ &EE
	  ...
	 / ]

	ATOMIC_SPECIES
	 X  Mass_X  PseudoPot_X
	 Y  Mass_Y  PseudoPot_Y
	 Z  Mass_Z  PseudoPot_Z

	ATOMIC_POSITIONS { alat | bohr | crystal | angstrom }
	in all cases except calculation = 'neb' or 'smd' :
	  X 0.0  0.0  0.0  {if_pos(1) if_pos(2) if_pos(3)}
	  Y 0.5  0.0  0.0
	  Z O.0  0.2  0.2
	if calculation = 'neb' .OR. 'smd' :
	  first_image
	  X 0.0  0.0  0.0  {if_pos(1) if_pos(2) if_pos(3)}
	  Y 0.5  0.0  0.0
	  Z O.0  0.2  0.2
	  { intermediate_image 1
	    X 0.0  0.0  0.0
	    Y 0.9  0.0  0.0
	    Z O.0  0.2  0.2
	    intermediate_image ...
	    X 0.0  0.0  0.0
	    Y 0.9  0.0  0.0
	    Z O.0  0.2  0.2 }
	  last_image
	  X 0.0  0.0  0.0
	  Y 0.7  0.0  0.0
	  Z O.0  0.5  0.2

	K_POINTS { tpiba | automatic | crystal | gamma }
	if (gamma)
	   nothing to read
	if (automatic)
	   nk1, nk2, nk3, k1, k2, k3
	if (not automatic)
	   nks
	   xk_x, xk_y, xk_z,  wk

	[ CELL_PARAMETERS { cubic | hexagonal }
	   v1(1) v1(2) v1(3)
	   v2(1) v2(2) v2(3)
	   v3(1) v3(2) v3(3) ]

	[ OCCUPATIONS
	   f_inp1(1)  f_inp1(2)  f_inp1(3) ... f_inp1(10)
	   f_inp1(11) f_inp1(12) ... f_inp1(nbnd)
	 [ f_inp2(1)  f_inp2(2)  f_inp2(3) ... f_inp2(10)
	   f_inp2(11) f_inp2(12) ... f_inp2(nbnd) ] ]

	[ CLIMBING_IMAGES
	   list of images, separated by a comma ]

	[ CONSTRAINTS
	   nconstr  { constr_tol }
	   constr_type(.)   constr(1,.)   constr(2,.) [ constr(3,.)   constr(4,.) ] { constr_target(.) } ]

	[ COLLECTIVE_VARS
	   ncolvar  { colvar_tol }
	   colvar_type(.)   colvar(1,.)   colvar(2,.) [ colvar(3,.)   colvar(4,.) ] ]
    }


    #
    # namelist CONTROL
    #

    namelist CONTROL {

	var calculation -type CHARACTER {
	    default { 'scf' }
	    info {
		a string describing the task to be performed:
		'scf', 'nscf', 'bands', 'phonon', 'relax', 'md',
		'vc-relax', 'vc-md', 'neb', 'smd', 'metadyn'
		(vc = variable-cell).
	    }
	}
	
	var title -type CHARACTER {
	    default {' '}
	    info {
		reprinted on output.
	    }
	}
	
	var verbosity -type CHARACTER {
	    info {
		'high' | 'default' | 'low' | 'minimal'
	    }
	}
	
	var restart_mode -type CHARACTER {
	    default { 'from_scratch' }
	    info {
		'from_scratch'  : from scratch
	                          NEB and SMD only: the starting path is obtained
	                          with a linear interpolation between the images
	                          specified in the ATOMIC_POSITIONS card.
			          Note that in the linear interpolation
	                          periodic boundary conditions ARE NON USED.
	    
		'restart'       : from previous interrupted run
	    }
	}
	
	var wf_collect -type LOGICAL { 
	    default { .FALSE. }
	    info {
		This flag controls the way wavefunctions are stored to disk :

		.TRUE.  collect wavefunctions from all processors and store
                        them into the output data directory outdir/prefix.save

		.FALSE. do not collect wavefunctions, leave them in temporary
	                local files (one per processor). The resulting format
	                will be readable only by jobs running on the same
	                number of processors and pools. Useful if you do not
	                need the wavefunction or if you want to reduce the I/O
	                or the disk occupancy.
	    }
	}
	

	var nstep -type INTEGER {
	    info {
		number of ionic + electronic steps
	    }
	    default {
		1  if calculation = 'scf', 'nscf', 'bands';
		0  if calculation = 'neb', 'smd';
		50 for the other cases
	    }
	}
	
	var iprint -type INTEGER {
	    default { write only at convergence }
	    info {
		band energies are written every iprint iterations
	    }
	}
	
	var tstress -type LOGICAL {
	    info {
		calculate stress. Set to .TRUE. if calculation='vc-md'
	    }
	}
	
	
	var tprnfor -type LOGICAL {
	    info {
		print forces. Set to .TRUE. if calculation='relax','md','vc-md'
	    }
	}
	
	var dt -type REAL { 
	    default { 20.D0 }
	    info {
		time step for molecular dynamics, in Rydberg atomic units
		(1 a.u.=4.8378 * 10^-17 s : beware, CP and FPMD codes use
		 Hartree atomic units, half that much!!!)
	    }
	}
	
	var outdir -type CHARACTER { 
	    default { 
		value of the ESPRESSO_TMPDIR environment variable if set; 
		current directory ('./') otherwise 
	    }
	    info {
		input, temporary, output files are found in this directory,
		see also 'wfcdir'
	    }
	}

	var wfcdir -type CHARACTER { 
	    default { same as outdir }
	    info {
		this directory specifies where to store files generated by
		each processor (*.wfc{N}, *.igk{N}, etc.). The idea here is
		to be able to separately store the largest files, while
		the files necessary for restarting still go into 'outdir'
		(for now only works for stand alone PW )
	    }
	}
	
	var prefix -type CHARACTER { 
	    default { 'pwscf' }
	    info {
		prepended to input/output filenames:
		prefix.wfc, prefix.rho, etc.
	    }
	}

	var lkpoint_dir -type LOGICAL { 
	    default { .true. }
	    info {
		If .false. it does not open a subdirectory for each k_point 
		in the prefix.save directory. 
	    }
	}
       		
	var max_seconds -type REAL { 
	    default { 1.D+7, or 150 days, i.e. no time limit }
	    info {
		jobs stops after max_seconds CPU time
	    }	    
	}

	var etot_conv_thr -type REAL { 
	    default { 1.0D-4 }
	    info {
		convergence threshold on total energy (a.u) for ionic
		minimization: the convergence criterion is satisfied
		when the total energy changes less than etot_conv_thr
		between two consecutive scf steps.
		See also forc_conv_thr - both criteria must be satisfied
	    }
	}

	var forc_conv_thr -type REAL { 
	    default { 1.0D-3 }
	    info {
		convergence threshold on forces (a.u) for ionic
		minimization: the convergence criterion is satisfied
		when all components of all forces are smaller than
		forc_conv_thr.
		See also etot_conv_thr - both criteria must be satisfied
	    }
	}
		
	var disk_io -type CHARACTER { 
	    default { 'default' }
	    info {
               Specifies the amount of disk I/O activity
               'high':    save all data at each SCF step

               'default': save wavefunctions at each SCF step unless
                          there is a single k-point per process

               'low' :    store wfc in memory, save only at the end

               'none':    do not save wfc, not even at the end

               If restarting from an interrupted calculation, the code
               will try to figure out what is available on disk. The
               more you write, the more complete the restart will be.
	    }
	}

	var pseudo_dir -type CHARACTER { 
	    default { 
		value of the $ESPRESSO_PSEUDO environment variable if set; 
		'$HOME/espresso/pseudo/' otherwise 
	    }
	    info {
		directory containing pseudopotential files
	    }
	}

	var tefield -type LOGICAL { 
	    default { .FALSE. }
	    info {
		If .TRUE. a sawlike potential simulating an electric field
		is added to the bare ionic potential. See variables
		edir, eamp, emaxprog, eopreg for the form and size of
		the added potential.
	    }
	}

	var dipfield -type LOGICAL { 
	    default { .FALSE. }
	    info {
		If .TRUE. and tefield=.TRUE. a dipole correction is also
		added to the bare ionic potential - implements the recipe
		of L. Bengtsson, PRB 59, 12301 (1999). See variables edir,
		emaxprog, eopreg for the form of the correction, that must
		be used only in a slab geometry, for surface calculations,
		with the discontinuity in the empty space.
	    }
	}

	var lelfield -type LOGICAL { 
	    default { .FALSE. }
	    info {
		If .TRUE. a homogeneous finite electric field described
		through the modern theory of the polarization is applied.
		This is different from "tefield=.true." !
	    }
	}
	
	var lberry -type LOGICAL {  
	    default { .FALSE. }
	    info {
		If .TRUE. perform a Berry phase calculation
		See the header of PW/bp_c_phase.f90 for documentation
	    }
	}
		
	var gdir -type INTEGER {
	    info {
               For Berry phase calculation: direction of the k-point
               strings in reciprocal space. Allowed values: 1, 2, 3
               1=first, 2=second, 3=third reciprocal lattice vector
               For calculations with finite electric fields
               (lelfield==.true.), gdir is the direction of the field
	    }
	}

	var nppstr -type INTEGER {
	    info {
		For Berry phase calculation: number of k-points to be
		calculated along each symmetry-reduced string
		The same for calculation with finite electric fields
		(lelfield==.true.)
	    }
	}

	var nberrycyc -type INTEGER { 
	    default { 1 }
	    info {
		In the case of a finite electric field  ( lelfield == .TRUE. )
		it defines the number of iterations for converging the
		wavefunctions in the electric field Hamiltonian, for each
		external iteration on the charge density
	    }
	}
    }

    #
    # NAMELIST &SYSTEM
    #

    namelist SYSTEM {

	var ibrav -type INTEGER {
	    status { REQUIRED }
	    info {
                Bravais-lattice index:
              
                  ibrav        structure                   celldm(2)-celldm(6)
              
                    0          "free", see above                 not used
                    1          cubic P (sc)                      not used
                    2          cubic F (fcc)                     not used
                    3          cubic I (bcc)                     not used
                    4          Hexagonal and Trigonal P        celldm(3)=c/a
                    5          Trigonal R                      celldm(4)=cos(alpha)
                    6          Tetragonal P (st)               celldm(3)=c/a
                    7          Tetragonal I (bct)              celldm(3)=c/a
                    8          Orthorhombic P                  celldm(2)=b/a,celldm(3)=c/a
                    9          Orthorhombic base-centered(bco) celldm(2)=b/a,celldm(3)=c/a
                   10          Orthorhombic face-centered      celldm(2)=b/a,celldm(3)=c/a
                   11          Orthorhombic body-centered      celldm(2)=b/a,celldm(3)=c/a
                   12          Monoclinic P                    celldm(2)=b/a,celldm(3)=c/a,
                                                               celldm(4)=cos(ab)
                   13          Monoclinic base-centered        celldm(2)=b/a,celldm(3)=c/a,
                                                               celldm(4)=cos(ab)
                   14          Triclinic                       celldm(2)= b/a,
                                                               celldm(3)= c/a,
                                                               celldm(4)= cos(bc),
                                                               celldm(5)= cos(ac),
                                                               celldm(6)= cos(ab)
              
                For P lattices: the special axis (c) is the z-axis, one basal-plane
                vector (a) is along x, the other basal-plane vector (b) is at angle
                gamma for monoclinic, at 120 degrees for trigonal and hexagonal
                lattices, at 90 degrees for cubic, tetragonal, orthorhombic lattices
              
                sc simple cubic
                ====================
                v1 = a(1,0,0),  v2 = a(0,1,0),  v3 = a(0,0,1)
              
                fcc face centered cubic
                ====================
                v1 = (a/2)(-1,0,1),  v2 = (a/2)(0,1,1), v3 = (a/2)(-1,1,0).
              
                bcc body entered cubic
                ====================
                v1 = (a/2)(1,1,1),  v2 = (a/2)(-1,1,1),  v3 = (a/2)(-1,-1,1).
              
                simple hexagonal and trigonal(p)
                ====================
                v1 = a(1,0,0),  v2 = a(-1/2,sqrt(3)/2,0),  v3 = a(0,0,c/a).
              
                trigonal(r)
                ===================
                for these groups, the z-axis is chosen as the 3-fold axis, but the
                crystallographic vectors form a three-fold star around the z-axis,
                and the primitive cell is a simple rhombohedron. The crystallographic
                vectors are:
                      v1 = a(tx,-ty,tz),   v2 = a(0,2ty,tz),   v3 = a(-tx,-ty,tz).
                where c=cos(alpha) is the cosine of the angle alpha between any pair
                of crystallographic vectors, tc, ty, tz are defined as
                     tx=sqrt((1-c)/2), ty=sqrt((1-c)/6), tz=sqrt((1+2c)/3)
              
                simple tetragonal (p)
                ====================
                   v1 = a(1,0,0),  v2 = a(0,1,0),  v3 = a(0,0,c/a)
              
                body centered tetragonal (i)
                ================================
                   v1 = (a/2)(1,-1,c/a),  v2 = (a/2)(1,1,c/a),  v3 = (a/2)(-1,-1,c/a).
              
                simple orthorhombic (p)
                =============================
                   v1 = (a,0,0),  v2 = (0,b,0), v3 = (0,0,c)
              
                bco base centered orthorhombic
                =============================
                   v1 = (a/2,b/2,0),  v2 = (-a/2,b/2,0),  v3 = (0,0,c)
              
                face centered orthorhombic
                =============================
                   v1 = (a/2,0,c/2),  v2 = (a/2,b/2,0),  v3 = (0,b/2,c/2)
              
                body centered orthorhombic
                =============================
                   v1 = (a/2,b/2,c/2),  v2 = (-a/2,b/2,c/2),  v3 = (-a/2,-b/2,c/2)
              
                monoclinic (p)
                =============================
		   v1 = (a,0,0), v2= (b*cos(gamma), b*sin(gamma), 0),  v3 = (0, 0, c)
                where gamma is the angle between axis a and b
              
                base centered monoclinic
                =============================
                   v1 = (  a/2,         0,                -c/2),
                   v2 = (b*cos(gamma), b*sin(gamma), 0),
                   v3 = (  a/2,         0,                  c/2),
                where gamma is the angle between axis a and b
              
                triclinic
                =============================
                   v1 = (a, 0, 0),
                   v2 = (b*cos(gamma), b*sin(gamma), 0)
                   v3 = (c*cos(beta),  c*(cos(alpha)-cos(beta)cos(gamma))/sin(gamma),
                         c*sqrt( 1 + 2*cos(alpha)cos(beta)cos(gamma)
                                   - cos(alpha)^2-cos(beta)^2-cos(gamma)^2 )/sin(gamma) )
                where alpha is the angle between axis b and c
                       beta is the angle between axis a and c
                      gamma is the angle between axis a and b
	    }	
	}
	
	dimension celldm -start 1 -end 6 -type REAL {
	    see  { ibrav }
	    info {
		Crystallographic constants - see description of ibrav variable.

		* alat = celldm(1) is the lattice parameter "a" (in BOHR)
		* only needed celldm (depending on ibrav) must be specified
		* if ibrav=0 only alat = celldm(1) is used (if present)
	    }
	}

	vargroup -type REAL {
	    var A
	    var B
	    var C
	    var cosAB
	    var cosAC
	    var cosBC
	    info {
		Traditional crystallographic constants (a,b,c in ANGSTROM),
		cosab = cosine of the angle between axis a and b
		specify either these OR celldm but NOT both.
		If ibrav=0 only alat = a is used (if present)
	    }
	}
						   
	var nat -type INTEGER {
	    status { REQUIRED }
	    info {
		number of atoms in the unit cell
	    }
	}
	
	var ntyp -type INTEGER {
	    status { REQUIRED }	    
	    info {
		number of types of atoms in the unit cell
	    }
	}

	var nbnd -type INTEGER {
	    default {
		for an insulator, nbnd = number of valence bands
		(nbnd=nelec/2, see below for nelec);
		for a metal, 20% more (minimum 4 more)
	    }
	    info {
		number of electronic states (bands) to be calculated.
		Note that in spin-polarized calculations the number of
		k-point, not the number of bands per k-point, is doubled
	    }
	}
	
	var nelec -type REAL {
	    default { the same as ionic charge (neutral cell) }
	    info {
		number of electron in the unit cell
		(may be noninteger if you wish)
		
		A compensating jellium background is inserted
		to remove divergences if the cell is not neutral
	    }
	}
		
	var tot_charge -type INTEGER { 
	    default { 0 }
	    info {
		total system charge. Used only if nelec is unspecified,
		otherwise it is ignored.
	    }
	}
	
	var ecutwfc -type REAL {
	    status { REQUIRED }
	    info {
		kinetic energy cutoff (Ry) for wavefunctions
	    }
	}
	
	var ecutrho -type REAL { 
	    default { 4 * ecutwfc }
	    info {
		kinetic energy cutoff (Ry) for charge density and potential
		May be larger ( for ultrasoft PP ) or somewhat smaller
		( but not much smaller ) than the default value. Note that
		if you have norm-conserving PP only, setting it to a larger
		value than the default is a waste of time.
	    }
	}
	
	vargroup -type INTEGER {
	    var nr1
	    var nr2
	    var nr3
	    info {
		three-dimensional FFT mesh (hard grid) for charge
		density (and scf potential). If not specified
		the grid is calculated based on the cutoff for
		charge density (see also "ecutrho")
	    }
	}

	vargroup -type INTEGER {
	    var nr1s
	    var nr2s
	    var nr3s
	    info {
		three-dimensional mesh for wavefunction FFT and for the smooth
		part of charge density ( smooth grid ).
		Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default )
	    }
	}
	
	var nosym -type LOGICAL { 
	    default { .FALSE. }
	    info {
		if (.TRUE.) symmetry is not used. Note that a k-point grid
		provided in input is used "as is"; an automatically generated
		k-point grid will contain only points in the irreducible BZ
		of the lattice.  Use with care in low-symmetry large cells
		if you cannot afford a k-point grid with the correct symmetry.
	    }
	}

	var noinv -type LOGICAL { 
	    default { .FALSE. }
	    info {
		if (.TRUE.) disable the usage of time reversal (q => -q) 
		symmetry in k-point generation
	    }
	}

	var occupations -type CHARACTER {
	    info {
		'smearing':     gaussian smearing for metals
		                requires a value for degauss

		'tetrahedra' :  for metals and DOS calculation
                                (see PRB49, 16223 (1994))
                                Requires uniform grid of k-points,
                                automatically generated (see below)
                                Not suitable (because not variational) for
                                force/optimization/dynamics calculations

		'fixed' :       for insulators with a gap

		'from_input' :  The occupation are read from input file.
                                Presently works only with one k-point
                                (LSDA allowed).
	    }
	}

	var degauss -type REAL { 
	    default { 0.D0 Ry }
	    info {
		value of the gaussian spreading (Ry) for brillouin-zone
		integration in metals.
	    }
	}
	
	var smearing -type CHARACTER {
	    default { 'gaussian' }
	    info {
		'gaussian', 'gauss':
		    ordinary Gaussian spreading (Default)
		    
		'methfessel-paxton', 'm-p', 'mp':
		    Methfessel-Paxton first-order spreading
		    (see PRB 40, 3616 (1989)).
		    
		'marzari-vanderbilt', 'cold', 'm-v', 'mv':
		    Marzari-Vanderbilt cold smearing
		    (see PRL 82, 3296 (1999))
		    
		'fermi-dirac', 'f-d', 'fd':
		    smearing with Fermi-Dirac function
	    }
	}
	
	var nspin -type INTEGER {
	    default { 1 }
	    info {
		nspin = 1 :  non-polarized calculation (default)
		
		nspin = 2 :  spin-polarized calculation, LSDA
		             (magnetization along z axis)

		nspin = 4 :  spin-polarized calculation, noncollinear
                             (magnetization in generic direction)
                             DO NOT specify nspin in this case;
                             specify "noncolin=.TRUE." instead
	    }
	}

	var noncolin -type LOGICAL {
	    default { .false. }
	    info {
		if .true. the program will perform a noncollinear calculation.
	    }
	}
	
	dimension starting_magnetization -start 1 -end ntyp -type REAL {
	    info {
		starting spin polarization (values between -1 and 1)
		on atomic type 'i' in a spin-polarized calculation.
		Breaks the symmetry and provides a starting point for
		self-consistency. The default value is zero, BUT a value
		MUST be specified for AT LEAST one atomic type in spin
		polarized calculations. Note that if start from zero
		initial magnetization, you will get zero final magnetization
		in any case. If you desire to start from an antiferromagnetic
		state, you may need to define two different atomic species
		corresponding to sublattices of the same atomic type.
		If you fix the magnetization with "nelup/neldw" or with
		"multiplicity" or with "tot_magnetization", you should
		not specify starting_magnetization.
		If you are restarting from a previous run, or from an
		interrupted run, starting_magnetization is ignored.
	    }
	}
	
	vargroup -type REAL {
	    var nelup
	    var neldw 
	    info {
		number of spin-up and spin-down electrons, respectively
		Note that this fixes the final value of the magnetization.
		The sum must yield nelec that must also be specified
		explicitly in this case. Not valid for spin-unpolarized
		or noncollinear calculations, only for LSDA. Obsolescent:
		use multiplicity or tot_magnetization instead.
	    }
	}

	var multiplicity -type INTEGER { 
	    default { 0 [unspecified] }
	    info {
		spin multiplicity (2s+1). 1 is singlet, 2 for doublet etc.
		Note that this fixes the final value of the magnetization.
		if unspecified or a non-zero value is specified in nelup/neldw
		then multiplicity variable is ignored.
		Do not specify both multiplicity and tot_magnetization.
	    }
	}

	var tot_magnetization -type INTEGER { 
	    default { -1 [unspecified] }
	    info {
		majority spin - minority spin (nelup - neldw).
		if unspecified or a non-zero value is specified in nelup/neldw
		then tot_magnetization variable is ignored.
		Do not specify both multiplicity and tot_magnetization.
		YES, there is redundancy! nelup/neldw are enough to specify
		the spin state. However these variables are not very convenient
		and will be eliminated from the input in future versions.
		It is recommended to use either 'multiplicity' or equivalently
		'tot_magnetization' to specify the spin state.
	    }
	}
	
	var ecfixed -type REAL { default { 0.0 }; see { q2sigma } }	    
	var qcutz   -type REAL { default { 0.0 }; see { q2sigma } }	    
	var q2sigma -type REAL { 
	    default { 0.1 } 
	    info { 
		ecfixed, qcutz, q2sigma:  parameters for modified functional to be 
		used in variable-cell molecular dynamics (or in stress calculation).
		"ecfixed" is the value (in Rydberg) of the constant-cutoff;
		"qcutz" and "q2sigma" are the height and the width (in Rydberg)
		of the energy step for reciprocal vectors whose square modulus
		is greater than "ecfixed". In the kinetic energy, G^2 is
		replaced by G^2 + qcutz * (1 + erf ( (G^2 - ecfixed)/q2sigma) )
		See: M. Bernasconi et al, J. Phys. Chem. Solids 56, 501 (1995)
	    }
	}
	
	var xc_type -type CHARACTER {
	    status { presently UNUSED: XC functional is read from PP files }
	    info {
		Exchange-correlation functional		    
	    }
	}

	var lda_plus_u        -type LOGICAL { 
	    default { .FALSE. }
	    see { Hubbard_U } 
	}
	dimension Hubbard_alpha -start 1 -end ntyp -type REAL { 
	    default { 0.D0 for all species }
	    see { Hubbard_U } 
	}
	dimension Hubbard_U -start 1 -end ntyp -type REAL {      
	    default { 0.D0 for all species }
	    status {
		LDA+U works only for a few selected elements. Modify
		PW/set_hubbard_l.f90 and PW/tabd.f90 if you plan to use LDA+U with an
		element that is not configured there.
	    }
	    info {
		lda_plus_u, Hubbard_alpha(i), Hubbard_U(i): parameters for LDA+U
		calculations If lda_plus_u = .TRUE. you must specify, for species i,
		the parameters U and (optionally) alpha of the Hubbard model (both in eV). 
		See: Anisimov, Zaanen, and Andersen, PRB 44, 943 (1991); Anisimov
		et al., PRB 48, 16929 (1993); Liechtenstein, Anisimov, and Zaanen, PRB
		52, R5467 (1994); Cococcioni and de Gironcoli, PRB 71, 035105 (2005).
	    }
	}
	
	var starting_ns_eigenvalue(m,ispin,I) -type REAL { 
	    default { -1.d0 that means NOT SET }
	    info {
		In the first iteration of an LDA+U run it overwrites
		the m-th eigenvalue of the ns occupation matrix for the
		ispin component of atomic species I. Leave unchanged
		eigenvalues that are not set. This is useful to suggest
		the desired orbital occupations when the default choice
		takes another path.
	    }
	}

	var U_projection_type -type CHARACTER {   
	    default { 'atomic' }
	    info {
		Only active when lda_plus_U is .true., specifies the type
		of projector on localized orbital to be used in the LDA+U
		scheme.

		Currently available choices:
		'atomic': use atomic wfc's (as they are) to build the projector

		'ortho-atomic': use Lowdin orthogonalized atomic wfc's
		
		'norm-atomic':  Lowdin normalization of atomic wfc. Keep in mind:
                                atomic wfc are not orthogonalized in this case.
                                This is a "quick and dirty" trick to be used when
                                atomic wfc from the pseudopotential are not
                                normalized (and thus produce occupation whose
                                value exceeds unity). If orthogonalized wfc are
                                not needed always try 'atomic' first.

		'file':         use the information from file "prefix".atwfc that must
                                have been generated previously, for instance by pmw.x
                                (see PP/poormanwannier.f90 for details)

		NB: forces and stress currently implemented only for the
		'atomic' choice.
	    }
	}

	var edir -type INTEGER {
	    info {
		The direction of the electric field or dipole correction is
		parallel to the bg(:,edir) reciprocal lattice vector, so the
		potential is constant in planes defined by FFT grid points;
		edir = 1, 2 or 3. Used only if tefield is .TRUE.
	    }
	}
	
	var emaxpos -type REAL { 
	    default { 0.5D0 }
	    info {
		Position of the maximum of the sawlike potential along crystal
		axis "edir", within the  unit cell (see below), 0 < emaxpos < 1
		Used only if tefield is .TRUE.
	    }
	}
	
	var eopreg -type REAL {
	    default { 0.1D0 }
	    info {
		Zone in the unit cell where the sawlike potential decreases.
		( see below, 0 < eopreg < 1 ). Used only if tefield is .TRUE.
	    }
	}

	var eamp -type REAL { 
	    default { 0.001 a.u. }
	    info {
		Amplitude of the electric field (in a.u. = 51.44 10^10 V/m )
		The sawlike potential increases with slope "eamp" in the
		region from (emaxpos+eopreg-1) to (emaxpos), then decreases
		to 0 until (emaxpos+eopreg), in units of the crystal
		vector "edir". Used only if tefield is .TRUE.
	    }
	}

	dimension angle1 -start 1 -end ntyp -type REAL {
	    info {
		The angle expressed in degrees between the initial
		magnetization and the z-axis. For noncollinear calculations
		only; index i runs over the atom types.
	    }
	}

	dimension angle2 -start 1 -end ntyp -type REAL {
	    info {
		The angle expressed in degrees between the projection
		of the initial magnetization on x-y plane and the x-axis.
		For noncollinear calculations only.
	    }
	}

	var constrained_magnetization -type CHARACTER { 
	    default { 'none' }
	    info {
		Used to perform constrained calculations in magnetic systems.
		Currently available choices:

		'none':  
		         no constraint

		'total': 
		         total magnetization is constrained
                         If nspin=4 (noncolin=.True.) constraint is imposed by
                         adding a penalty functional to the total energy:
		    
		         LAMBDA * SUM_{i} ( magnetization(i) - fixed_magnetization(i) )**2
                        
		         where the sum over i runs over the three components of
                         the magnetization. Lambda is a real number (see below).
                         If nspin=2 constraint is imposed by defining two Fermi
                         energies for spin up and down.
                         Only fixed_magnetization(3) can be defined in this case.
		
		'atomic': 
                         atomic magnetization are constrained to the defined
                         starting magnetization adding a penalty:

		         LAMBDA * SUM_{i,itype} ( magnetic_moment(i,itype) - mcons(i,itype) )**2
                        
		         where i runs over the cartesian components (or just z 
                         in the collinear case) and itype over the types (1-ntype).
                         mcons(:,:) array is defined from starting_magnetization,
                         (and angle1, angle2 in the non-collinear case). lambda is 
                         a real number
		
		'total direction':  
		          the angle theta of the total magnetization
                          with the z axis (theta = fixed_magnetization(3))  
                          is constrained: 

		          LAMBDA * ( magnetization(1) - magnetization(3)*tan(theta) )**2
		
		'atomic direction': 
		          not all the components of the atomic
                          magnetic moment are constrained but only the cosine
                          of angle1, and the penalty functional is:

		          LAMBDA * SUM_{itype} ( mag_mom(3,itype)/mag_mom_tot - cos(angle1(ityp)) )**2
	    }
	}
	
	dimension fixed_magnetization -start 1 -end 3 -type REAL { 
	    default { 0.d0 }
	    info {
		value of the total magnetization to be maintained fixed when
		constrained_magnetization='total'
	    }
	}
	
	dimension B_field -start 1 -end 3 -type REAL { 
	    default { 0.d0 } 
	    info {		    
		A fixed magnetic field defined by the vector B_field is added
		to the exchange and correlation magnetic field.
		The three components of the magnetic field are given in Ry.
		Only B_field(3) can be used if nspin=2.
		
		In all calculations with a finite magnetic field,
		we print the total energy WITHOUT the B dot M term.
		In the calculations with the penalty functional we write
		only the total energy, NOT the penalty functional.
	    }
	}
	
	var lambda -type REAL {
	    info {
		parameter used for constrained_magnetization calculations
		NB: LAMBDA is reduced in the first iterations and is increased
		    slowly up to the input value.
	    }
	}
	
	var report -type INTEGER {
	    info {
		It's the number of iterations after which the program
		write all the atomic magnetic moments.
	    }
	}
	
	var lspinorb -type LOGICAL {
	    info {
		if .TRUE. the noncollinear code can use a pseudopotential with
		spin-orbit.
	    }
	}
	
	var assume_isolated -type LOGICAL { 
	    default { .FALSE. } 
	    info {
		if .TRUE. the system is assumed to be isolated (a molecule or cluster
		in a supercell) and the Makov-Payne correction to the total energy is
		computed. An estimate of the vacuum level is also calculated so that
		eigenvalues can be properly aligned.
	    }
	}

        var do_ee -type LOGICAL {
           default { .FALSE. }
           info {
               if .TRUE. the system is embedded the electrostatic environment
               described in the EE namelist.
           }
        }
    }

    #
    # namelist ELECTRONS
    #

    namelist ELECTRONS {

	var electron_maxstep 	-type INTEGER { 
	    default { 100 }
	    info {
		maximum number of iterations in a scf step
	    }
	}

	var conv_thr -type REAL { 
	    default { 1.D-6 }
	    info {
		Convergence threshold for selfconsistency:
		estimated energy error < conv_thr
	    }
	}
	 
	var mixing_mode -type CHARACTER {
	    default { 'plain' }
	    info {
		'plain' :    charge density Broyden mixing
		
		'TF' :       as above, with simple Thomas-Fermi screening
		            (for highly homogeneous systems)
		
		'local-TF':  as above, with local-density-dependent TF screening
		             (for highly inhomogeneous systems)
	    }
	}

	var mixing_beta -type REAL { 
	    default { 0.7D0 }
	    info {
		mixing factor for self-consistency
	    }
	}

	var mixing_ndim -type INTEGER { 
	    default { 8 }
	    info {
		number of iterations used in mixing scheme
	    }
	}

	var mixing_fixed_ns -type INTEGER { 
	    default { 0 }
	    info {
		For LDA+U : number of iterations with fixed ns ( ns is the
  	        atomic density appearing in the Hubbard term ).
	    }
	}
	
	var diagonalization -type CHARACTER {
	    default { 'david' }
	    info {
               'david':  Davidson iterative diagonalization with overlap matrix
                         (default). Fast, may in some rare cases fail.

               'cg' :    conjugate-gradient-like band-by-band diagonalization
                         Typically slower than 'david' but it uses less memory
                         and is more robust (it fails very seldom)

               'david-serial': do not use parallel subspace diagonalization 
                         in Davidson algorithm (for testing purposes).
                         The subspace diagonalization in Davidson is performed
                         by a fully distributed-memory parallel algorithm on
                         4 or more processors, by default. The allocated memory
                         scales down with the number of procs. Procs involved 
                         in diagonalization can be changed with input parameter
                         "ortho_para". On multicore CPUs often it is convenient
                         to let only one core per CPU to work on linear algebra.
	    }
	}

	var ortho_para -type INTEGER { 
	    default { 0 }
	    status { OBSOLESCENT: use command-line option " -ndiag XX" instead  }
	    info {
		meaningful for diagonalization='david' and parallel executables.
		The number of processors to be used for the parallel subspace
		diagonalization algorithm. With the default value (0) the code
		tries to use as many processors as available. Note that the
		algorithm uses a square number of processors (4, 9, 16, 25,...),
		so the actual number of processors used will be the largest
		square number less or equal to ortho_para (if set) or to the 
		total number of processors (if ortho_para is not set).
	    }
	}

	var diago_thr_init -type REAL {
	    info {
		Convergence threshold for the first iterative diagonalization
		(the check is on eigenvalue convergence).
		For scf calculations, the default is 1.D-2 if starting from a
		superposition of atomic orbitals; 1.D-5 if starting from a
		charge density. During self consistency the threshold (ethr)
		is automatically reduced when approaching convergence.
		For non-scf calculations, this is the threshold used in the
		iterative diagonalization. The default is conv_thr / nelec.
		For 'phonon' calculations, diago_thr_init is ignored:
		the threshold is always set to  conv_thr / nelec .
	    }
	}

	var diago_cg_maxiter -type INTEGER {
	    info {
		For conjugate gradient diagonalization:
		max number of iterations
	    }
	}

	var diago_david_ndim -type INTEGER { 
	    default { 4 }
	    info {
		For Davidson diagonalization: dimension of workspace
		(number of wavefunction packets, at least 2 needed).
		A larger value may yield a faster algorithm but uses
		more memory
	    }
	}

	#var diago_diis_ndim -type INTEGER { 
	#    default { 3 }
	#    info {
	#	For DIIS: dimension of the reduced space.
	#    }
	#}

	var diago_full_acc -type LOGICAL { 
	    default { .FALSE. }
	    info {
		If .TRUE. all the empty states are diagonalized at the same level
		of accuracy of the occupied ones. Otherwise the empty states are
		diagonalized using a larger threshold (this should not affect
                total energy, forces, and other ground-state properties).
	    }
	}

	var efield -type REAL { 
	    default { 0.D0 }
	    info {
		For finite electric field calculations (lelfield == .TRUE.),
		it defines the intensity of the field in a.u.
	    }
	}

	var startingpot -type CHARACTER {
	    info {
               'atomic': starting potential from atomic charge superposition
                         ( default for scf, *relax, *md, neb, smd )

               'file'  : start from existing "charge-density.xml" file
                         ( default, only possibility for nscf, bands, phonon )
	    }
	}

	var startingwfc -type CHARACTER {
	    default { 'atomic' }
	    info {
               'atomic': start from superposition of atomic orbitals
                         If not enough atomic orbitals are available,
                         fill with random numbers the remaining wfcs
                         The scf typically starts better with this option,
                         but in some high-symmetry cases one can "loose" 
                         valence states, ending up in the wrong ground state.

               'atomic+random': as above, plus a superimposed "randomization"
                         of atomic orbitals. Prevents the "loss" of states 
                         mentioned above.

               'random': start from random wfcs. Slower start of scf but safe.
                         It may also reduce memory usage in conjunction with
                         diagonalization='cg'

               'file':   start from a wavefunction file
	    }
	}

	var tqr -type LOGICAL { 
	    default { .FALSE. }
	    info {
		If .true., use the (VERY EXPERIMENTAL) real-space algorithm
		for augmentation charges in ultrasoft pseudopotentials.
		Must faster execution of ultrasoft-related calculations,
		but numerically less accurate than the default algorithm.
		Use with care and after testing!
	    }
	}
    }

    
    #
    # NAMELIST IONS
    #
    
    namelist IONS  {
	label { 
	    input this namelist only if calculation = 'relax', 'md', 'vc-relax', 'vc-md', 'neb', 'smd' 
	}
    
	var ion_dynamics -type CHARACTER {
	    info {
		Specify the type of ionic dynamics.

		For constrained dynamics or constrained optimisations add the
		CONSTRAINTS card (when the card is present the SHAKE algorithm is
				  automatically used).

		For different type of calculation different possibilities are
		allowed and different default values apply:

		CASE ( calculation = 'relax' )
                    'bfgs' :   (default)   a new BFGS quasi-newton algorithm, based
                                           on the trust radius procedure, is used
                                           for structural relaxation (experimental)
		    'damp' :               use damped (quick-min Verlet)
                                           dynamics for structural relaxation

		CASE ( calculation = 'md' )
                    'verlet' : (default)   use Verlet algorithm to integrate
		                           Newton's equation
                    'langevin'             ion dynamics is over-damped Langevin

		CASE ( calculation = 'vc-relax' )
                    'damp' :   (default)   use damped (Beeman) dynamics for
		                           structural relaxation

		CASE ( calculation = 'vc-md' )
                    'beeman' : (default)   use Beeman algorithm to integrate
                                           Newton's equation
	    }
	}
    
	var phase_space -type CHARACTER { 
	    default { 'full' }
	    info {
		'full' :           the full phase-space is used for the ionic
                                   dynamics.

		'coarse-grained' : a coarse-grained phase-space, defined by a set
                                   of constraints, is used for the ionic dynamics
                                   (used for calculation of free-energy barriers)
	    }
	}

	var pot_extrapolation -type CHARACTER { 
	    default { 'atomic' }
	    info {
               Used to extrapolate the potential from preceding ionic steps.

               'none'        :  no extrapolation

               'atomic'      :  extrapolate the potential as if it was a sum of
                                atomic-like orbitals

               'first_order' :  extrapolate the potential with first-order
                                formula

               'second_order':  as above, with second order formula
	    }
	}

	var wfc_extrapolation -type CHARACTER { 
	    default { 'none' }
	    info {
		Used to extrapolate the wavefunctions from preceding ionic steps.

               'none'        :  no extrapolation

               'first_order' :  extrapolate the wave-functions with first-order
                                formula - NOT IMPLEMENTED WITH USPP

               'second_order':  as above, with second order formula
                                NOT IMPLEMENTED WITH USPP
	    }
	}

	var remove_rigid_rot -type LOGICAL { 
	    default { .FALSE. }
	    info {
               This keyword is useful when simulating the dynamics and/or the
               thermodynamics of an isolated system. If set to true the total
               torque of the internal forces is set to zero by adding new forces
               that compensate the spurious interaction with the periodic
               images. This allowes for the use of smaller supercells.

               BEWARE: since the potential energy is no longer consistent with
               the forces (it still contains the spurious interaction with the
               repeated images), the total energy is not conserved anymore.
               However the dynamical and thermodynamical properties should be
               in closer agreement with those of an isolated system.
               Also the final energy of a structural relaxation will be higher,
               but the relaxation itself should be faster.
	    }
	}
    	 
	group {
	    label {
		keywords used for molecular dynamics
	    }	    

	    var ion_temperature -type CHARACTER {
		default { 'not_controlled' }
		info { 
		    'rescaling'   control ionic temperature via velocity rescaling
                                  (first method) see parameters "tempw" and "tolp"
                                  This is the only method implemented in VC-MD

		    'rescale-v'   control ionic temperature via velocity rescaling
                                  (second method) see parameters "tempw" and "nraise"

		    'rescale-T'   control ionic temperature via velocity rescaling
                                  (third method) see parameter "delta_t"

		    'reduce-T'    reduce ionic temperature every "nraise" steps
                                  by the (negative) value "delta_t"

		    'berendsen'   control ionic temperature using "soft" velocity
                                  rescaling - see parameters "tempw" and "nraise"

		    'andersen'    control ionic temperature using Andersen thermostat
                                  see parameters "tempw" and "nraise"

		    'not_controlled' (default) ionic temperature is not controlled
		}
	    }

	    var tempw -type REAL { 
		default { 300.D0 }
		info {
		    Starting temperature (Kelvin) in MD runs
		    target temperature for most thermostats.
		}
	    }

	    var tolp -type REAL { 
		default { 100.D0 }
		info {
		    Tolerance for velocity rescaling. Velocities are rescaled if
		    the run-averaged and target temperature differ more than tolp.
		}
	    }

	    var delta_t -type REAL { 
		default { 1.D0 }
		info {
		    if ion_temperature='rescale-T':
		           at each step the instantaneous temperature is multiplied
		           by delta_t; this is done rescaling all the velocities.

		    if ion_temperature='reduce-T':
		           every 'nraise' steps the instantaneous temperature is
		           reduced by -delta_T (.e. delta_t is added to the temperature)

		    The instantaneous temperature is calculated at the end of
		    every ionic move and BEFORE rescaling. This is the temperature
		    reported in the main output.
		
		    For delta_t < 0, the actual average rate of heating or cooling
		    should be roughly C*delta_t/(nraise*dt) (C=1 for an
                    ideal gas, C=0.5 for a harmonic solid, theorem of energy
                    equipartition between all quadratic degrees of freedom).
		}
	    }

	    var nraise -type INTEGER { 
		default { 1 }
		info {
		    if ion_temperature='reduce-T':
		           every 'nraise' steps the instantaneous temperature is
		           reduced by -delta_T (.e. delta_t is added to the temperature)
		
		    if ion_temperature='rescale-v':
		           every 'nraise' steps the average temperature, computed from
		           the last nraise steps, is rescaled to tempw
		    
		    if ion_temperature='berendsen':
		           the "rise time" parameter is given in units of the time step:
		           tau = nraise*dt, so dt/tau = 1/nraise
		    
		    if ion_temperature='andersen':
		           the "collision frequency" parameter is given as nu=1/tau
		           defined above, so nu*dt = 1/nraise
		}
	    }

	    var refold_pos -type LOGICAL { 
		default { .FALSE. }
		info {
		    This keyword applies only in the case of molecular dynamics or
		    damped dynamics. If true the ions are refolded at each step into
		    the supercell.
		}
	    }
	}
    
	group {
	    label {
		keywords used only in BFGS calculations
	    }


	    var upscale -type REAL { 
		default { 10.D0 }
		info {
		    Max reduction factor for conv_thr during structural optimization
		    conv_thr is automatically reduced when the relaxation
		    approaches convergence so that forces are still accurate,
		    but conv_thr will not be reduced to less that
		    conv_thr / upscale.
		}
	    }

	    var bfgs_ndim -type INTEGER { 
		default { 1 }
		info {
		    Number of old forces and displacements vectors used in the
		    PULAY mixing of the residual vectors obtained on the basis
		    of the inverse hessian matrix given by the BFGS algorithm.
		    When bfgs_ndim = 1, the standard quasi-Newton BFGS method is
		    used.
		    (bfgs only)
		}
	    }

	    var trust_radius_max -type REAL { 
		default { 0.8D0 }
		info {
		    Maximum ionic displacement in the structural relaxation.
		    (bfgs only)
		}
	    }

	    var trust_radius_min -type REAL { 
		default { 1.D-3 }
		info {
		    Minimum ionic displacement in the structural relaxation
		    BFGS is reset when trust_radius < trust_radius_min.
		    (bfgs only)
		}
	    }

	    var trust_radius_ini -type REAL { 
		default { 0.5D0 }
		info {
		    Initial ionic displacement in the structural relaxation.
		    (bfgs only)
		}
	    }
	
	    var w_1 -type REAL { default { 0.01D0 }; see { w_2 } }
	    var w_2 -type REAL { 
		default { 0.5D0 }
		info {
		    Parameters used in line search based on the Wolfe conditions.
		    (bfgs only)
		}
	    }
	}
    
	group {
	    label {
		keywords used only in NEB and SMD calculations
	    }

	    var num_of_images -type INTEGER { 
		default { 0 }
		info {
		    Number of points used to discretize the path
		    (it must be larger than 3).
		}
	    }

	    var opt_scheme -type CHARACTER { 
		default { 'quick-min' }
		info {
		    Specify the type of optimization scheme:

		    'sd'         : steepest descent

		    'broyden'    : quasi-Newton Broyden's second method (suggested)

		    'quick-min'  : an optimisation algorithm based on the
		                   projected velovity Verlet scheme

		    'langevin'   : finite temperature langevin dynamics of the
                                   string (smd only). It is used to compute the
                                   average path and the free-energy profile.
		}
	    }

	    var CI_scheme -type CHARACTER {
		default { 'no-CI' }
		info {
		    Specify the type of Climbing Image scheme:

		    'no-CI'      : climbing image is not used

		    'auto'       : original CI scheme. The image highest in energy
	                           does not feel the effect of springs and is
			           allowed to climb along the path

		    'manual'     : images that have to climb are manually selected.
		                   See also CLIMBING_IMAGES card
		}
	    }

	    var first_last_opt -type LOGICAL { 
		default { .FALSE. }
		info {
		    Also the first and the last configurations are optimised
		    "on the fly" (these images do not feel the effect of the springs).
		}
	    }

	    var temp_req -type REAL { 
		default { 0.D0 Kelvin }
		info {
		    Temperature used for the langevin dynamics of the string.
		}
	    }

	    var ds -type REAL { 
		default { 1.D0 }
		info {
		    Optimisation step length ( Hartree atomic units ).
		    If opt_scheme="broyden", ds is used as a guess for the diagonal
		    part of the Jacobian matrix.
		}
	    }

	    vargroup -type REAL {
		var k_max
		var k_min
		default { 0.1D0 Hartree atomic units }
		info {
		    Set them to use a Variable Elastic Constants scheme
		    elastic constants are in the range [ k_min, k_max ]
		    this is useful to rise the resolution around the saddle point.
		}
	    }

	    var path_thr -type REAL { 
		default { 0.05D0 eV / Angstrom }
		info {
		    The simulation stops when the error ( the norm of the force
	            orthogonal to the path in eV/A ) is less than path_thr.
		}
	    }

	    var use_masses -type LOGICAL { 
		default { .FALSE. }
		info {
		    If. TRUE. the optimisation of the path is performed using
		    mass-weighted coordinates.
		}
	    }

	    var use_freezing -type LOGICAL { 
		default { .FALSE. }
		info {
		    If. TRUE. the images are optimised according to their error:
		    only those images with an error larger than half of the largest
		    are optimised. The other images are kept frozen.
		}
	    }
	}

	group {	    
	    label {
		keywords used only in meta-dynamics calculations 
		( see also the card COLLECTIVE_VARS )
	    }

	    dimension fe_step -start 1 -end ncolvar -type REAL { 
		default { 0.04 }
		info {
		    Meta-dynamics step length (in principle different for each
		    collective variable), defined using the same units used
		    to define the collective variables themselves.
		    The step also defines the spread of the Gaussian-like bias
		    potential.
		}
	    }

	    var g_amplitude -type REAL { 
		default { 0.005 Hartree }
		info {
		    Amplitude of the gaussians used in meta-dynamics.
		}
	    }

	    var fe_nstep -type INTEGER { 
		default { 100 }
		info {
		    Maximum number of steps used to evaluate the potential of
		    mean force.
		}
	    }

	    var sw_nstep -type INTEGER { 
		default { 10 }
		info {
		    Number of steps used to switch to the new values of the
		    collective variables.
		}
	    }
	}
    }

    #
    # namelist CELL
    #

    namelist CELL {
	label {
	    input this namelist only if calculation = 'vc-relax', 'vc-md' 
	}

	var cell_dynamics -type CHARACTER {
	    info {
               Specify the type of dynamics for the cell.
               For different type of calculation different possibilities
               are allowed and different default values apply:

               CASE ( calculation = 'vc-relax' )
                 'none':    default
                 'sd':      steepest descent ( not implemented )
                 'damp-pr': damped (Beeman) dynamics of the Parrinello-Rahman
                            extended lagrangian
                 'damp-w':  damped (Beeman) dynamics of the new Wentzcovitch
                            extended lagrangian
                 'bfgs':    new BFGS quasi-newton algorithm, based on the trust
                            radius procedure, is used for structural relaxation
                            (experimental), ion_dynamics must be 'bfgs' too
               CASE ( calculation = 'vc-md' )
                 'none': default
                 'pr':      (Beeman) molecular dynamics of the Parrinello-Rahman
                            extended lagrangian
                 'w':       (Beeman) molecular dynamics of the new Wentzcovitch
                            extended lagrangian
	    }
	}

	var press -type REAL { 
	    default { 0.D0 }
	    info { 
		Target pressure [KBar] in a variable-cell md or relaxation run. 
	    }
	}

	var wmass -type REAL { 
	    default {
		0.75*Tot_Mass/pi**2 for Parrinello-Rahman MD;
		0.75*Tot_Mass/pi**2/Omega**(2/3) for Wentzcovitch MD
	    }
	    info {
               Fictitious cell mass [amu] for variable-cell simulations
               (both 'vc-md' and 'vc-relax')
	    }
	}

	var cell_factor -type REAL { 
	    default { 1.2D0 }
	    info {
		Used in the construction of the pseudopotential tables.
		It should exceed the maximum linear contraction of the
		cell during a simulation.
	    }
	}

	var press_conv_thr -type REAL { 
	    default { 0.5D0 Kbar }
	    info {
		Convergence threshold on the pressure for variable cell
		relaxation ('vc-relax' : note that the other convergence
	        thresholds for ionic relaxation apply as well).
	    }
	}

	var cell_dofree -type CHARACTER { 
	    default { 'all' }
	    info {
               Select which of the cell parameters should be moved:

               all     = all axis and angles are propagated
               volume  = the cell is simply rescaled, without changing the shape
               x       = only the x axis is moved
               y       = only the y axis is moved
               z       = only the z axis is moved
               xy      = only the x and y axis are moved, angles are unchanged
               xz      = only the x and z axis are moved, angles are unchanged
               yz      = only the y and z axis are moved, angles are unchanged
               xyz     = x, y and z axis are moved, angles are unchanged
               xyt     = x1, x2, y2 (i.e. lower xy triangle of the 2 vectors)
               xys     = x1, y1, x2, y2 (i.e. xy square of the 2 vectors)
               xyzt    = x1, x2, y2, x3, y3, z3 (i.e. lower xyz triangle of 
                         the 3 vectors)
	    }
	}
    }

    #
    # namelist PHONON
    #

    namelist PHONON {
	label {
	    input this namelist only in calculation = 'phonon' 
	}

	var modenum -type INTEGER { 
	    default { 0 }
	    info {
		For single-mode phonon calculation : modenum is the index of the
		irreducible representation (irrep) into which the reducible
		representation formed by the 3*nat atomic displacements are
		decomposed in order to perform the phonon calculation.
	    }
	}

	dimension xqq -start 1 -end 3 -type REAL {
	    info {
		q-point (units 2pi/a) for phonon calculation.
	    }
	}
    }

    #
    # namelist EE
    #

    namelist EE {
	label {
	    input this namelist only when do_ee is .TRUE. in SYSTEM namelist 
	}

	var which_compensation -type CHARACTER { 
	    default { 'none' }
	    info {
                 'dcc' : density counter charge correction.
                         The electrostatic problem is solved in open boundary 
                         conditions. At variance with the Makov-Payne approach
                         that only estimates an energy correction here the
                         scf potential is corrected as well.
                         Theory described in: 
                         I.Dabo, B.Kozinsky, N.E.Singh-Miller and N.Marzari,
                         "Electrostatic periodic boundary conditions and 
                         real-space corrections", Phys.Rev.B 77, 115139 (2008)
	    }
	}

	var ecutcoarse -type REAL { 
            default { 100 }
            info { kinetic energy cutoff defining the grid used for 
                  the open boundary correction.
            }
        }

	var mixing_charge_compensation -type REAL { 
            default { 1.0 }
            info { scf mixing parameter for the correcting potential.
            }
        }

	var n_charge_compensation -type INTEGER { 
            default { 5 }
            info { the correcting potential is updated (mixed) every 
                   n_charge_compensation iteration only.
            }
        }

	var comp_thr -type REAL { 
            default { 1.d-4 }
            info { inclusion of dcc correction begins when scf convergence
                   is better than comp_thr.
            }
        }

	var nlev -type INTEGER { 
            default { 4 }
            info { number of depth levels used by the multigrid solver.
            }
        }
    }

    #
    # card ATOMIC_SPECIES
    #
    card ATOMIC_SPECIES {
	syntax {
	    table atomic_species {
		rows -start 1 -end ntyp {
		    col X -type CHARACTER { info { label of the atom } }
		    col Mass_X -type REAL {
			info {
			    mass of the atomic species [amu: mass of C = 12]
			    not used if calculation='scf','nscf', 'bands', 'phonon'
			}
		    }
		    col PseudoPot_X -type CHARACTER {
			info {
			    File containing PP for this species.
	    
			    The pseudopotential file is assumed to be in the new UPF format.
			    If it doesn't work, the pseudopotential format is determined by
			    the file name:
			    
			    *.vdb or *.van     Vanderbilt US pseudopotential code
			    *.RRKJ3            Andrea Dal Corso's code (old format)
			    none of the above  old PWscf norm-conserving format
			}
		    }
		}
	    }
	}
    }

    #
    # card ATOMIC_POSITIONS
    #

    card ATOMIC_POSITIONS {

	flag atompos_unit -use optional {
	    enum { alat | bohr | angstrom | crystal }
	    default { alat }
	    info {
	        alat    : atomic positions are in cartesian coordinates,
                          in units of the lattice parameter "a" (default)
	        
	        bohr    : atomic positions are in cartesian coordinate, 
	                  in atomic units (i.e. Bohr)
	        
	        angstrom: atomic positions are in cartesian coordinates, 
                          in Angstrom
	        
	        crystal : atomic positions are in crystal coordinates, i.e.
                          in relative coordinates of the primitive lattice vectors (see below)
	    }
	}

	choose {
	    when -test "calculation != 'neb' AND calculation != 'smd'" {
		syntax {
		    # non-path calculation
		    
		    table atomic_coordinates {
			rows -start 1 -end nat {
			    col X -type CHARACTER {
				info { label of the atom as specified in ATOMIC_SPECIES }
			    }

			    colgroup -type REAL {
				info { atomic positions }
				col x
				col y
				col z
			    }
			    
			    optional {
				colgroup -type INTEGER {						
				    info {
					component i of the force for this atom is multiplied by if_pos(i),
					which must be either 0 or 1.  Used to keep selected atoms and/or
					selected components fixed in meta-dynamics, neb, smd, MD dynamics or
					structural optimization run.
				    }
				    default { 1 }
				    
				    col if_pos(1)
				    col if_pos(2)
				    col if_pos(3)
				}
			    }
			}
		    }
		}

	    }
	    elsewhen -test "calculation = 'neb' OR calculation = 'smd'" {		

		# path-calculation

		message { 
		    There are at least two groups of cards, each group is composed 
		    by an identifier followed by "nat" lines as specified above:
		    
			identifier
			X  x y z   { if_pos(1) if_pos(2) if_pos(3) }
		    
		    The first group ( identifier="first_image" ) contains the first image; 
		    the last group  ( identifier="last_image" )  contains the last image. 
			
		    There is also the possibility of specifying intermediate images; 
		    in this case their coordinates must be set between the first_image 
		    and the last_image ( identifier="intermediate_image", followed by 
		    "nat" position lines ).		    

		    IMPORTANT: 
		    Several intermediate images may be specified via intermediate_image
		    identifier, but the total number of configurations specified in the
		    input file must be less than num_of_images (as specified in &IONS).
		    The initial path is obtained interpolating between the specified
		    configurations so that all images are equispaced (only the coordinates 
		    of the first and last images are not changed).
		}

		syntax {
		    		
		    # first_image
		    
		    line { keyword first_image }
		    table atomic_coordinates_first_image {
			rows -start 1 -end nat {
			    col X -type CHARACTER {}
			    colgroup -type REAL {
				col x
				col y
				col z
			    }
			    
			    optional {
				colgroup -type INTEGER {						
				    col if_pos(1)
				    col if_pos(2)
				    col if_pos(3)
				}
			    }			
			}		
		    }

		    # intermediate_image

		    optional {
			line { keyword intermediate_image }		    
			table atomic_coordinates_intermediate_image {
			    rows -start 1 -end nat {
				col X -type CHARACTER {}
				colgroup -type REAL {
				    col x
				    col y
				    col z
				}				    
			    }
			}
		    }
		    
		    # last_image

		    line { keyword last_image }
		    table atomic_coordinates_last_image {
			rows -start 1 -end nat {
			    col X -type CHARACTER {}
			    colgroup -type REAL {
				col x
				col y
				col z
			    }				    
			}
		    }		
		}
	    }
	}
    }    


    #
    # K_POINTS
    #
    card K_POINTS {
	flag kpoint_type -use optional {
	    enum { tpiba | automatic | crystal | gamma }
	    default { tbipa }
	    info {
		tpiba    : read k-points in cartesian coordinates, 
                           in units of 2 pi/a (default)

		automatic: automatically generated uniform grid of k-points, i.e,
		           generates ( nk1, nk2, nk3 ) grid with ( sk1, sk2, sk3 ) offset.
		           nk1, nk2, nk3 as in Monkhorst-Pack grids
		           k1, k2, k3 must be 0 ( no offset ) or 1 ( grid displaced
			   by half a grid step in the corresponding direction )
		           BEWARE: only grids having the full symmetry of the crystal
                           work with tetrahedra. Some grids with offset may not work.
 
		crystal  : read k-points in crystal coordinates, i.e. in relative
		           coordinates of the reciprocal lattive vectors

		gamma    : use k = 0 (no need to list k-point specifications after card)
		           In this case wavefunctions can be chosen as real, 
		           and specialized subroutines optimized for calculations
		           at the gamma point are used (memory and cpu requirements 
                           are reduced by approximately one half).
	    }
	}

	choose {
	    when -test "tpiba  OR  crystal" {
		syntax -flag {tpiba | crystal} {
		    line { 
			var nks -type INTEGER {
			    info {Number of supplied special k-points.}
			}
		    }
		    table kpoints {
			rows -start 1 -end nks {
			    colgroup -type REAL {
				col xk_x 
				col xk_y
				col xk_z
				col wk
				info {
				    Special k-points (xk_x/y/z) in the irreducible Brillouin Zone
				    of the lattice (with all symmetries) and weights (wk)
				    See the literature for lists of special points and
				    the corresponding weights.
				    
				    If the symmetry is lower than the full symmetry
				    of the lattice, additional points with appropriate
				    weights are generated.

				    In a non-scf calculation, weights do not affect the results.
				    If you just need eigenvalues and eigenvectors (for instance,
				    for a band-structure plot), weights can be set to any value
				    (for instance all equal to 1).
				}
			    }
			}
		    }
		}		
	    }
	    elsewhen -test "automatic" {
		syntax -flag {automatic} {
		    line {
			vargroup -type INTEGER {
			    var nk1
			    var nk2
			    var nk3 
			    info { 
				These parameters specify the k-point grid 
				(nk1 x nk2 x nk3) as in Monkhorst-Pack grids. 
			    }
			}
			vargroup -type INTEGER {
			    var sk1
			    var sk2
			    var sk3
			    info {
				The grid offests;  sk1, sk2, sk3 must be 
				0 ( no offset ) or 1 ( grid displaced by 
                                half a grid step in the corresponding direction ).
			    }
			}
		    }
		}
	    }
	    elsewhen -test "gamma" {
		syntax -flag {gamma} {}
	    }
	}
    }

    #
    # CELL_PARAMETERS
    #
    card CELL_PARAMETERS {
	flag lattice_type -use optional {
	    enum {  cubic | hexagonal }
	    default { cubic }
	    info {
		Flag "cubic" or "hexagonal" specify if you want to look for symmetries
		derived from the cubic symmetry group (default) or from the hexagonal
		symmetry group (assuming c axis as the z axis, a axis along the x axis).
	    }
	}

	label { 
	    Optional card, needed only if ibrav = 0 is specified, ignored otherwise ! 
	}
	
	syntax {
	    table lattice {
		cols -start 1 -end 3 {
		    rowgroup -type REAL {
			info { 
			    Crystal lattice vectors:
			        v1(1)  v1(2)  v1(3)    ... 1st lattice vector
			        v2(1)  v2(2)  v2(3)    ... 2nd lattice vector
			        v3(1)  v3(2)  v3(3)    ... 3rd lattice vector
			    
			    In alat units if celldm(1) was specified or in a.u. otherwise.
			}		    
			row v1
			row v2
			row v3
		    }
		}
	    }
	}
    }


    #
    # CLIMBING_IMAGES
    #

    card CLIMBING_IMAGES {
	label { 
    	    Optional card, needed only if CI_scheme = 'manual', ignored otherwise ! 
    	}

    	syntax {
    	    list climbing_images_list -type INTEGER {
    		format { index1, index2, ... indexN }
    		info {		
    		    index1, index2, ..., indexN are indices of the images to which the 
    		    Climbing-Image procedure apply. If more than one image is specified 
    		    they must be separated by a comma.
    		}
    	    }
    	}
    }


    #
    # CONSTRAINTS
    #

    card CONSTRAINTS {
	label {
	    Optional card, used for constrained dynamics or constrained optimisations ! 	    
	}
	message {
	    When this card is present the SHAKE algorithm is automatically used.
	}

	syntax {
	    line {
		var nconstr -type INTEGER {
		    info { Number of constraints. }
		}
		
		optional {
		    var constr_tol -type REAL {
			info { Tolerance for keeping the constraints satisfied. }
		    }
		}
	    }
	    
	    table constraints_table {
		rows -start 1 -end nconstr {
		    col constr_type -type CHARACTER {
			info {
			    Type of constrain :

			    'type_coord'      : constraint on global coordination-number, i.e. the
                                                average number of atoms of type B surrounding the
                                                atoms of type A. The coordination is defined by
                                                using a Fermi-Dirac.
                                                (four indexes must be specified).

			    'atom_coord'      : constraint on local coordination-number, i.e. the
                                                average number of atoms of type A surrounding a
                                                specific atom. The coordination is defined by
                                                using a Fermi-Dirac.
                                                (four indexes must be specified).

			    'distance'        : constraint on interatomic distance 
			                        (two atom indexes must be specified).

			    'planar_angle'    : constraint on planar angle 
			                        (three atom indexes must be specified).

			    'torsional_angle' : constraint on torsional angle 
			                        (four atom indexes must be specified).

			    'bennett_proj'    : constraint on the projection onto a given direction
                                                of the vector defined by the position of one atom
                                                minus the center of mass of the others.
                                                ( Ch.H. Bennett in Diffusion in Solids, Recent
                                                  Developments, Ed. by A.S. Nowick and J.J. Burton,
                                                  New York 1975 ).
			}			
		    }
		    colgroup {
			col constr(1)
			col constr(2)
			conditional {
			    col constr(3)
			    col constr(4)
			}
			info {
			    These variables have different meanings 
			    for different constraint types:

                           'type_coord' : constr(1) is the first index of the
                                          atomic type involved
                                          constr(2) is the second index of the
                                          atomic type involved
                                          constr(3) is the cut-off radius for
                                          estimating the coordination
                                          constr(4) is a smoothing parameter

                           'atom_coord' : constr(1) is the atom index of the
                                          atom with constrained coordination
                                          constr(2) is the index of the atomic
                                          type involved in the coordination
                                          constr(3) is the cut-off radius for
                                          estimating the coordination
                                          constr(4) is a smoothing parameter

                             'distance' : atoms indices object of the
                                          constraint, as they appear in
                                          the 'ATOMIC_POSITION' CARD

      'planar_angle', 'torsional_angle' : atoms indices object of the
                                          constraint, as they appear in the
                                          'ATOMIC_POSITION' CARD (beware the
                                          order)

                         'bennett_proj' : constr(1) is the index of the atom
                                          whose position is constrained.
                                          constr(2:4) are the three coordinates
                                          of the vector that specifies the
                                          constraint direction.
			}
		    }

		    optional {
			col constr_target -type REAL {
			    info {
				Target for the constrain ( angles are specified in degrees ).
				This variable is optional.
			    }
			}
		    }
		}
	    }
	}
    }

    #
    # COLLECTIVE_VARS
    #

    card  COLLECTIVE_VARS {
	label {
	    Optional card, used for meta-dynamics calculations !
	}

	syntax {
	    line {
		var ncolvar -type INTEGER {
		    info { Number of collective variables. }
		}
		
		optional {
		    var colvar_tol -type REAL {
			info { Tolerance used for SHAKE. }
		    }
		}
	    }
	    
	    table collective_vars_table {
		rows -start 1 -end ncolvar {
		    col colvar_type -type CHARACTER {
			see { constr_type }
			info {
			    See the definition of constr_type in the CONSTRAINTS card.
			}
		    }
		    colgroup {
			col colvar(1)
			col colvar(2)
			conditional {
			    col colvar(3)
			    col colvar(4)
			}
			info {
			    These variables have different meanings for 
			    different collective variable types. See the 
			    definition of constr in the CONSTRAINTS card.
			}
			see { constr(1) }
		    }
		}
	    }
	}
    }

    #
    # card OCCUPATIONS
    #

    card OCCUPATIONS {
	label { Optional card, used only if occupations = 'from_input', ignored otherwise ! }
	syntax {
	    table occupations_table {
	    	cols -start 1 -end nbnd {
	    	    row f_inp1 -type REAL {
	    		info { 
	    		    Occupations of individual states. 
	    		    For spin-polarized calculation, these are majority spin states. 
	    		}
	    	    }
	    	    conditional {
	    		row f_inp2 -type REAL {
	    		    info { 				
	    			Occupations of minority spin states for spin-polarized calculation; 
	    			specify only for spin-polarized calculation.
	    		    }
	    		}
	    	    }
	    	}
	    }

	    #list majority_states -type REAL {
	    #	format { 
	    #	    f_inp(1,1)  f_inp(2,1)  f_inp(3,1) ... f_inp(10,1)
	    #	    f_inp(11,1) f_inp(12,1) ... f_inp(nbnd,1)
	    #	}
	    #	info {
	    #	    Occupations of individual states. 
	    #	    For spin-polarized calculation, these are majority spin states. 
	    #	}
	    #}
	    #optional {
	    #	list minority_states -type REAL {
	    #	    format {
	    #		f_inp(1,2)  f_inp(2,2)  f_inp(3,2) ... f_inp(10,2)
	    #		f_inp(11,2) f_inp(12,2) ... f_inp(nbnd,2)
	    #	    }
	    #	    info { 				
	    #		Occupations of minority spin states for spin-polarized calculation; 
	    #		specify only for spin-polarized calculation.
	    #	    }
	    #	}
	    #}
	}
    }	
}
