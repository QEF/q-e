#
# $RCSfile: settings.itcl,v $ --
#
#      This file contains ...
#
# Copyright (c) 2004  Anton Kokalj   Email: tone.kokalj@ijs.si
#
#
# This file is distributed under the terms of the GNU General Public
# License. See the file `COPYING' in the root directory of the present
# distribution, or http://www.gnu.org/copyleft/gpl.txt .
#
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
# ANTON KOKALJ BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
#
# $Id: settings.itcl,v 1.7 2009-07-16 16:58:45 kokalj Exp $ 
#
proc ::pwscf::settings {gui} {

    set t [::tku::toplevelExists .pwgui_settings]
    
    set obj [_settingsModule]
    
    ::guib::widgets::dialogshell $t -title "PWgui Settings" -separator 1 -transient 0
    $t add Close  -text Close  -command [list destroy $t]    
    $t add Save   -text Save   -command [list ::pwscf::_settingsSave  $obj]
    $t add Apply  -text Apply  -command [list ::pwscf::_settingsApply $obj]
    $t add OK     -text "Apply & Close" -command [list ::pwscf::_settingsOK    $t $obj]
    $t default OK

    #
    # build the GUI recursively
    #
    set cs [$t childsite]
    $obj makeEmbedGUI $cs

    $t configure -width 700
    #::tku::centerWindow $t
}

proc ::pwscf::_settingsOK {t obj} {
    _settingsApply $obj
    destroy $t
}

proc ::pwscf::_settingsApply {obj} {
    $obj saveToVar ::pwscf

    puts stderr [array get ::pwscf::settings]
    puts stderr "::pwscf::settings_how_exe = $::pwscf::settings_how_exe"

    if { $::pwscf::settings_how_exe == "path" } {
	set ::pwscf::settings(PW)   $::pwscf::settings(BINDIR)/pw.x
	set ::pwscf::settings(PH)   $::pwscf::settings(BINDIR)/ph.x
	set ::pwscf::settings(PP)   $::pwscf::settings(BINDIR)/pp.x
	set ::pwscf::settings(PROJWFC) $::pwscf::settings(BINDIR)/projwfc.x
	set ::pwscf::settings(D3)   $::pwscf::settings(BINDIR)/d3.x
	set ::pwscf::settings(LD1)   $::pwscf::settings(BINDIR)/ld1.x
    }
}

proc ::pwscf::_settingsSave {obj} {
    _settingsApply $obj

    switch $::tcl_platform(platform) {
        unix {
	    # save settings to $HOME/.pwgui/pwgui.settings
	    _settingsSave_Unix $obj
        } macintosh {
	    # I don't know how to do it for macintosh
            _settingsSave_Unix $obj
        } default {
	    # ... and neither for MS-Windows
	    _settingsSave_Unix $obj
        }
    }
}

proc ::pwscf::_settingsSave_Unix {obj} {
    global env
    set dir [file join $env(HOME) .pwgui]
    if { ! [file exists $dir] } {
	# $HOME/.pwgui/ does not exists yet, create it
	if { [catch {file mkdir $dir}] } {
	    ::tku::errorDialog "unable to save PWgui Settings, because directory $dir can't be created"
	}
    }    
    if { [file isdirectory $dir] } {
	_settingsSaveToFile $obj $dir/pwgui.settings
    } else {
	::tku::errorDialog "unable to save PWgui Settings, because \"$dir\" is not directory"
    }
}

proc ::pwscf::_settingsSaveToFile {obj file} {
    ::tclu::DEBUG _settingsSaveToFile: $obj

    set vars [$obj getAllVar var]
    set    content "# ---------------------------------------------------------------------\n"
    append content "# BEWARE: this file was generated by PWgui\n"
    append content "#         and will be overwritten by PWgui upon Save-settings request\n"
    append content "# ---------------------------------------------------------------------\n\n"

    foreach var $vars {
	upvar \#0 $var varValue
	if { [info exists varValue] } {
	    append content "set $var \"${varValue}\"\n"
	}
    }
    ::tclu::writeFile $file $content
}

    

proc ::pwscf::_settingsModule {} {
    set obj [::guib::moduleObj settings\#auto -title "PWgui: settings" -script {

	optionSetDefault line     decor normal
	optionSetDefault namelist decor normal

	page pwscf -name "PWscf settings" {
	    line pwscf_fix -name "Prefix & postfix (i.e. Prefix = mpirun -np 2  &&  Postfix = -npool 2)" {
		var RUN.prefix  -variable ::pwscf::settings(RUN.prefix)  -label "Prefix:"
		var RUN.postfix -variable ::pwscf::settings(RUN.postfix) -label "Postfix:"
	    }
	    line pwscf_exe -name "Specify executables (i.e. /usr/local/bin/pw.x)" {
		auxilvar HOW_EXE {
		    -label "How to specify executables:"
		    -widget radiobox
		    -textvalue {
			"by specifying the path"
			"each executable separately"
		    }
		    -value { path binaries }
		}	    

		group path -decor normal {
		    var BINDIR -variable ::pwscf::settings(BINDIR) -label "Specify the path for QE binaries:" -widget entrydirselect
		}

		group binaries -decor normal {
		    var PW -variable ::pwscf::settings(PW) -label "Executable \"pw.x\":" -widget entryfileselect
		    var PH -variable ::pwscf::settings(PH) -label "Executable \"ph.x\":" -widget entryfileselect
		    var PP -variable ::pwscf::settings(PP) -label "Executable \"pp.x\":" -widget entryfileselect
		    var PROJWFC -variable ::pwscf::settings(PROJWFC) -label "Executable \"projwfc.x\":" -widget entryfileselect
		    var D3      -variable ::pwscf::settings(D3) -label "Executable \"d3.x\":" -widget entryfileselect
		    var LD1     -variable ::pwscf::settings(LD1) -label "Executable \"ld1.x\":" -widget entryfileselect
		}
	    }
	}

	page general -name "PWgui settings" {    
	    line pwguil1 -name "Editors & Viewers" {
		var EDITOR     -variable ::pwscf::settings(EDITOR)     -label "Text-file editor:" -widget combobox         
		var PAGER      -variable ::pwscf::settings(PAGER)      -label "Text-file viewer program:" -widget combobox
		var HTMLVIEWER -variable ::pwscf::settings(HTMLVIEWER) -label "HTML viewer program:" -widget combobox 
	    }
	    line pwguil2 -name "XCrySDen" {
		var XCRYSDEN.openAs {
		    -variable  ::pwscf::settings(XCRYSDEN.openAs) 
		    -label     "Launch XCRYSDEN:"
		    -value     {standalone notebook-page}
		    -textvalue {"as standalone application" "in notebook page"}
		    -widget    radiobox
		}
	    }
	}    

	page syntax -name "Input-syntax settings" {

	    line pIOl1 -name "FORTRAN namelists" {
		# take care of GUIB's settings() array
		var NAMELIST.end_regexp -variable ::guib::settings(NAMELIST.end_regexp) -label "Read-regexp for FORTRAN namelist end-marker:"
		var NAMELIST.end_string -variable ::guib::settings(NAMELIST.end_string) -label "Write-string for FORTRAN namelist end-marker:"
		var NAMELIST.varname_nocase {
		    -variable  ::guib::settings(NAMELIST.varname_nocase)
		    -label     "FORTRAN namelist variable's names\nare case insensitive:"
		    -textvalue {Yes No} -value {1 0}
		    -widget    radiobox
		}
		var NAMELIST.varname_format {
		    -variable  ::guib::settings(NAMELIST.varname_format)
		    -label     "FORTRAN namelist variable's name write format:"
		}
		var NAMELIST.variable_support_undefined {
		    -variable  ::guib::settings(NAMELIST.variable_support_undefined)
		    -label     "Allow undefined variables in the FORTRAN namelist:"
		    -textvalue {Yes No} -value {1 0}
		    -widget    radiobox
		}
	    }
	    # NOT SUPPORTED YET:
	    #line pIOl2 -name "Case sensitivity of input-files" {
	    #	var INPUT.nocase {
	    #	    -variable  ::guib::settings(INPUT.nocase)
	    #	    -label     "Syntax of input-files is case-sensitive"
	    #	    -textvalue {Yes No} -value {1 0}
	    #	    -widget    radiobox
	    #	}    
	    #	
	    #	
	    #	separator -label "-- Prefereces for case-insensitive input-file syntax --"
	    #	
	    #	var INPUT.nocase_preference_keyword {
	    #	    -variable  ::guib::settings(INPUT.nocase_preference_keyword)
	    #	    -label     "Write keywords as:"
	    #	    -value     {upper lower unchanged}
	    #	    -textvalue {"Upper-case" "Lower-case" "Unchanged"}
	    #	    -widget    optionmenu
	    #	}    
	    #	var INPUT.nocase_preference_varvalue {
	    #	    -variable  ::guib::settings(INPUT.nocase_preference_varvalue)
	    #	    -label     "Write string-values as:"
	    #	    -value     {upper lower unchanged}
	    #	    -textvalue {"Upper-case" "Lower-case" "Unchanged"}
	    #	    -widget    optionmenu
	    #	}
	    #}
	}

	page debug -name "DEBUG settings" {    
	    line p3l1 -name "DEBUGING" {
		# take care of GUIB's settings() array
		var ::tclu::DEBUG {
		    -label "Print debugging messages to StdOut/StdErr:" 
		    -value {1 0} -textvalue {Yes No}
		    -widget radiobox
		}
		var ::tclu::DEBUG_FILE {
		    -label "Print debugging messages to file DEBUG:" 
		    -value {1 0} -textvalue {Yes No}
		    -widget radiobox
		}
		
	    }
	}
	
	tracevar HOW_EXE w {
	    set how [varvalue HOW_EXE]
	    if { $how == "path" } {
		varset HOW_EXE -value path
		set ::pwscf::settings_how_exe path
		groupwidget path enable
		groupwidget binaries disable
	    } else {
		set ::pwscf::settings_how_exe binaries
		groupwidget path disable
		groupwidget binaries enable
	    }
	}
	
	postprocess {
	    loadFromVar
	    
	    #foreach var {
	    #	INPUT.nocase INPUT.nocase_preference_keyword INPUT.nocase_preference_varvalue
	    #} {
	    #	# not supported yet --> disable
	    #	widget $var disable
	    #}
	    
	    foreach elem {EDITOR PAGER} {
		widgetconfigure $elem -editable true -textvalues $::pwscf::settings($elem.list)
	    }
	    widgetconfigure PW -width 50

	    set how [varvalue HOW_EXE]
	    if { $how == {} } {
		varset HOW_EXE -value path
	    }
	    puts stderr "how=$how"
	}
    }]
    return $obj
}

